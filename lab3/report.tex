\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{listings}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\pgfplotsset{compat=1.18}
\usetikzlibrary{arrows.meta,positioning,calc}

\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    breaklines=true,
    frame=single
}

\begin{document}

% ============================================================
% Title page
% ============================================================
\begin{titlepage}
    \begin{center}
        \textsc{
            Санкт-Петербургский политехнический университет имени Петра Великого \\[5mm]
            Институт прикладной математики и механики\\[2mm]
            Высшая школа прикладной математики и физики
        }
        \vfill
        \textbf{\large
            Отчет \\
            по лабораторной работе \#3 \\
            по дисциплине <<Компьютерные сети>>\\[5mm]
            Задача византийских генералов.\\
            Алгоритм Лэмпорта--Шостака--Пиза
        }
        \vfill
        \begin{flushright}
            Выполнил студент\\
            группы 5040102/40201\\
            Шварц Александр\\[5mm]
            Преподаватель\\
            Баженов Александр Николаевич
        \end{flushright}
        \vfill
        Санкт-Петербург, 2025
    \end{center}
\end{titlepage}

\tableofcontents
\newpage

% ============================================================
\section{Введение}
% ============================================================

В распределённой системе несколько узлов обмениваются сообщениями по сети и должны прийти к единому решению. Если все узлы исправны, задача тривиальна. Сложность возникает, когда часть узлов может вести себя произвольно: отправлять разные значения разным адресатам, молчать или намеренно вносить противоречия. Такие сбои называют \emph{византийскими}, поскольку никакие предположения о характере ошибок не делаются.

Лэмпорт, Шосток и Пиз (1982) формализовали эту проблему как \emph{задачу византийских генералов} и предложили семейство алгоритмов $\mathrm{OM}(m)$, гарантирующих консенсус при определённом соотношении числа узлов и числа сбойных участников.

Цель работы --- реализовать алгоритм $\mathrm{OM}(m)$, экспериментально подтвердить его корректность, продемонстрировать необходимость условия $n \geq 3m+1$ и измерить сложность по числу сообщений.

% ============================================================
\section{Теоретические основы}
% ============================================================

\subsection{Модель системы}

Рассматривается система из $n$ процессов (<<генералов>>), связанных попарно надёжными аутентифицированными каналами: сообщения не теряются, не искажаются при передаче и получатель всегда знает, от кого пришло сообщение. Среди $n$ процессов не более $m$ являются \emph{византийскими} (сбойными): они могут отправлять произвольные значения, в том числе разные значения разным адресатам.

Один процесс выделен как \emph{командующий}; остальные $n-1$ называются \emph{лейтенантами}. Командующий имеет входное значение $v \in \{0, 1\}$, которое он должен передать лейтенантам.

\subsection{Условия корректности (Interactive Consistency)}

Алгоритм считается корректным, если при любом поведении византийских процессов выполняются оба условия:

\begin{itemize}
    \item \textbf{IC1 (согласие):} все лояльные лейтенанты принимают одно и то же решение $d$.
    \item \textbf{IC2 (корректность):} если командующий лоялен, то $d = v$.
\end{itemize}

Заметим, что IC2 сильнее IC1: из IC2 следует IC1 для случая лояльного командующего. Условие IC1 без IC2 нетривиально только когда командующий сам является предателем~--- тогда лояльные лейтенанты всё равно обязаны договориться о каком-то общем значении, пусть и отличном от того, что отправил командующий.

\subsection{Невозможность при $n \leq 3m$}

Прежде чем строить алгоритм, необходимо установить границу. Покажем, что при $n = 3$ и $m = 1$ задача неразрешима.

Пусть генералы $A$ (командующий), $B$ и $C$, причём $C$~--- предатель. Командующий отправляет $v = 1$ обоим лейтенантам. Лейтенант $B$ получает от $A$ значение~1, а от предателя $C$~--- значение~0 (ложь). Лейтенант $B$ видит голоса $(1, 0)$ и не может определить, кто из двоих лжёт. Теперь рассмотрим другую ситуацию: $A$~--- предатель, который отправил $B$ значение~1, а $C$ значение~0. Лояльный $C$ честно передаёт~0 лейтенанту $B$. С точки зрения $B$ обе ситуации неотличимы: он получает 1 от $A$ и 0 от $C$. Следовательно, $B$ не может корректно определить исходное значение.

Формально доказано~\cite{LSP82}, что для $n \leq 3m$ не существует алгоритма, удовлетворяющего IC1 и IC2. Отсюда необходимое условие:
\[
    n \geq 3m + 1.
\]

\subsection{Алгоритм $\mathrm{OM}(m)$}

Алгоритм Oral Messages определён рекурсивно по параметру $m$~--- максимальному числу предателей.

\medskip
\textbf{Базис: $\mathrm{OM}(0)$.} Предателей нет ($m = 0$).
\begin{enumerate}
    \item Командующий отправляет значение $v$ каждому из $n - 1$ лейтенантов.
    \item Каждый лейтенант принимает полученное значение как своё решение.
\end{enumerate}

\textbf{Рекурсия: $\mathrm{OM}(m)$, $m \geq 1$.} Участвуют $n$ генералов.
\begin{enumerate}
    \item Командующий отправляет значение $v_i$ каждому лейтенанту $i$ ($1 \leq i \leq n - 1$). Если командующий лоялен, то $v_i = v$ для всех $i$.
    \item Каждый лейтенант $i$ запускает $\mathrm{OM}(m-1)$ среди $n - 1$ генералов (все, кроме командующего), выступая в роли командующего с значением $v_i$. Обозначим результат, который лейтенант $j$ получает из подзадачи лейтенанта $i$, как $w_{j,i}$.
    \item Каждый лейтенант $j$ формирует вектор $(v_j,\; w_{j,1},\; \ldots,\; w_{j,j-1},\; w_{j,j+1},\; \ldots,\; w_{j,n-1})$ и принимает решение $d_j = \mathrm{majority}(\ldots)$~--- значение, встречающееся строго больше $\lfloor n/2 \rfloor$ раз (при равенстве используется значение по умолчанию).
\end{enumerate}

Ключевая идея: на шаге~2 каждый лейтенант \emph{перепроверяет} слова командующего через $(n-2)$ независимых свидетелей. Рекурсия гарантирует, что свидетельства тоже перепроверяются, и так $m$ раз~--- по числу возможных предателей.

\subsection{Корректность алгоритма}

\begin{itemize}
    \item \textbf{Теорема} (Лэмпорт и др., 1982). Алгоритм $\mathrm{OM}(m)$ удовлетворяет IC1 и IC2 при $n \geq 3m + 1$.
\end{itemize}

Доказательство проводится индукцией по $m$.

\emph{База} ($m = 0$): предателей нет, командующий лоялен и отправляет всем одно значение $v$. Все лейтенанты получают $v$~--- оба условия выполнены.

\emph{Шаг} ($m \to m+1$, $n \geq 3(m+1)+1 = 3m+4$): рассмотрим два случая.
\begin{enumerate}
    \item \emph{Командующий лоялен.} Он отправляет всем $v_i = v$. Каждый лейтенант $i$ запускает $\mathrm{OM}(m)$ с $n - 1 \geq 3m + 3 > 3m + 1$ участниками. Среди лейтенантов не более $m$ предателей. По предположению индукции $\mathrm{OM}(m)$ корректен, поэтому каждый лояльный лейтенант $j$ получает $w_{j,i} = v$ для всех лояльных $i$. В итоговом голосовании не менее $n - 1 - m$ значений равны $v$. Поскольку $n - 1 - m \geq 3m + 3 - m = 2m + 3 > (n-1)/2$, значение $v$ составляет строгое большинство: $d_j = v$ для всех лояльных $j$.
    \item \emph{Командующий~--- предатель.} Тогда среди $n - 1$ лейтенантов не более $m$ предателей. По предположению индукции все подзадачи $\mathrm{OM}(m)$ корректны, поэтому лояльные лейтенанты формируют одинаковые векторы значений. Применяя одну и ту же функцию majority, они получают одно и то же решение~--- IC1 выполнено.
\end{enumerate}

\subsection{Сложность}

Число сообщений $T(n, m)$ определяется рекуррентно. В $\mathrm{OM}(0)$ командующий отправляет $n - 1$ сообщение. В $\mathrm{OM}(m)$ командующий отправляет $n - 1$ сообщение, после чего каждый из $n - 1$ лейтенантов инициирует $\mathrm{OM}(m-1)$ среди $n - 1$ участника:
\[
    T(n, 0) = n - 1, \qquad T(n, m) = (n-1)\bigl(1 + T(n-1, m-1)\bigr).
\]
Раскрывая рекурсию, получаем:
\[
    T(n, m) = \sum_{k=0}^{m} \prod_{j=0}^{k} (n - 1 - j) \;=\; O(n^{m+1}).
\]
Алгоритм выполняется за $m + 1$ раундов коммуникации.

% ============================================================
\section{Реализация}
% ============================================================

Симулятор реализован на C++ (стандарт C++17) и состоит из следующих компонентов:

\begin{itemize}
    \item \textbf{General}~--- структура генерала с полями: идентификатор, флаг предательства, стратегия, начальное значение, генератор случайных чисел.
    \item \textbf{ByzantineStrategy}~--- перечисление стратегий предателей:
    \begin{itemize}
        \item \texttt{RANDOM}~--- случайное значение 0 или 1;
        \item \texttt{ALWAYS\_ZERO}~--- всегда отправляет 0;
        \item \texttt{ALWAYS\_OPPOSITE}~--- отправляет инвертированное значение;
        \item \texttt{SPLIT}~--- отправляет 0 первой половине, 1 второй половине.
    \end{itemize}
    \item \textbf{om\_algorithm()}~--- рекурсивная реализация $\mathrm{OM}(m)$.
    \item \textbf{run\_simulation()}~--- запуск одного эксперимента с проверкой IC1/IC2.
\end{itemize}

Подсчёт сообщений ведётся глобальным счётчиком, инкрементируемым при каждой отправке.

% ============================================================
\section{Результаты экспериментов}
% ============================================================

\subsection{Часть 1: Базовая корректность ($n=4$, $m=1$)}

Перебраны все комбинации командующий/предатель (4 командующих $\times$ 3 предателя $\times$ 2 значения = 24 запуска). Во всех случаях достигнуто согласие (IC1) и корректность (IC2).

\begin{table}[H]
\centering
\caption{Базовая корректность: $n=4$, $m=1$ (выборка)}
\label{tab:part1}
\begin{tabular}{cccccc}
\toprule
Командующий & Предатель & Значение & Согласие & Корректность & Сообщения \\
\midrule
0 & 1 & 0 & да & да & 9 \\
0 & 1 & 1 & да & да & 9 \\
0 & 2 & 0 & да & да & 9 \\
0 & 3 & 1 & да & да & 9 \\
1 & 0 & 0 & да & да & 9 \\
2 & 0 & 1 & да & да & 9 \\
3 & 1 & 0 & да & да & 9 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Часть 2: Масштабирование}

\begin{table}[H]
\centering
\caption{Масштабирование: доля согласия и корректности (20 испытаний)}
\label{tab:part2}
\begin{tabular}{ccccc}
\toprule
$n$ & $m$ & Доля согласия & Доля корректности & Ср. сообщения \\
\midrule
4  & 1 & 1.00 & 1.00 & 9 \\
7  & 1 & 1.00 & 1.00 & 36 \\
10 & 1 & 1.00 & 1.00 & 81 \\
13 & 1 & 1.00 & 1.00 & 144 \\
7  & 2 & 1.00 & 1.00 & 156 \\
10 & 2 & 1.00 & 1.00 & 585 \\
13 & 2 & 1.00 & 1.00 & 1\,464 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Часть 3: Граничный случай $n = 3m$ vs $n = 3m+1$}

\begin{table}[H]
\centering
\caption{Граничный случай: нарушение условия $n \geq 3m+1$}
\label{tab:part3}
\begin{tabular}{cclccc}
\toprule
$n$ & $m$ & Условие & Испытания & Доля согласия & Доля корректности \\
\midrule
3 & 1 & $n=3m$ (нарушено) & 50 & 1.00 & 0.76 \\
4 & 1 & $n=3m+1$ (выполнено) & 50 & 1.00 & 1.00 \\
6 & 2 & $n=3m$ (нарушено) & 50 & 0.96 & 0.84 \\
7 & 2 & $n=3m+1$ (выполнено) & 50 & 1.00 & 1.00 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Часть 4: Стратегии предателей ($n=7$, $m=2$)}

\begin{table}[H]
\centering
\caption{Влияние стратегий предателей при $n=7$, $m=2$ (20 испытаний)}
\label{tab:part4}
\begin{tabular}{llcc}
\toprule
Стратегия & Командующий & Доля согласия & Доля корректности \\
\midrule
RANDOM          & лояльный     & 1.00 & 1.00 \\
RANDOM          & предатель    & 1.00 & 1.00 \\
ALWAYS\_ZERO    & лояльный     & 1.00 & 1.00 \\
ALWAYS\_ZERO    & предатель    & 1.00 & 1.00 \\
ALWAYS\_OPPOSITE & лояльный    & 1.00 & 1.00 \\
ALWAYS\_OPPOSITE & предатель   & 1.00 & 1.00 \\
SPLIT           & лояльный     & 1.00 & 1.00 \\
SPLIT           & предатель    & 1.00 & 1.00 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Часть 5: Сложность сообщений}

\begin{table}[H]
\centering
\caption{Сравнение фактического и теоретического числа сообщений}
\label{tab:part5}
\begin{tabular}{cccc}
\toprule
$n$ & $m$ & Фактически & Теоретически \\
\midrule
4  & 1 & 9     & 9 \\
7  & 1 & 36    & 36 \\
10 & 1 & 81    & 81 \\
13 & 1 & 144   & 144 \\
16 & 1 & 225   & 225 \\
7  & 2 & 156   & 156 \\
10 & 2 & 585   & 585 \\
13 & 2 & 1\,464  & 1\,464 \\
10 & 3 & 3\,609  & 3\,609 \\
13 & 3 & 13\,344 & 13\,344 \\
\bottomrule
\end{tabular}
\end{table}

% ============================================================
% Figures
% ============================================================

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    gen/.style={circle, draw, minimum size=1cm, font=\small},
    traitor/.style={gen, fill=red!20},
    >=Stealth
]
    % Generals
    \node[gen] (G0) at (0, 3) {$G_0$};
    \node[gen] (G1) at (-3, 0) {$G_1$};
    \node[gen] (G2) at (0, 0) {$G_2$};
    \node[traitor] (G3) at (3, 0) {$G_3$};

    % Commander label
    \node[above=2mm of G0, font=\footnotesize] {Командующий};
    \node[below=2mm of G3, font=\footnotesize, red] {Предатель};

    % OM(1) Step 1: Commander sends
    \draw[->, thick, blue] (G0) -- node[left, font=\footnotesize] {$v=1$} (G1);
    \draw[->, thick, blue] (G0) -- node[right, font=\footnotesize] {$v=1$} (G2);
    \draw[->, thick, blue] (G0) -- node[right, font=\footnotesize] {$v=1$} (G3);

    % OM(0) Step 2: Each relays
    \draw[->, dashed, green!50!black] (G1) to[bend left=15] node[below, font=\tiny] {1} (G2);
    \draw[->, dashed, green!50!black] (G1) to[bend left=15] node[below, font=\tiny] {1} (G3);
    \draw[->, dashed, green!50!black] (G2) to[bend left=15] node[above, font=\tiny] {1} (G1);
    \draw[->, dashed, green!50!black] (G2) to[bend right=15] node[below, font=\tiny] {1} (G3);
    \draw[->, dashed, red] (G3) to[bend left=15] node[above, font=\tiny] {0} (G1);
    \draw[->, dashed, red] (G3) to[bend left=15] node[above, font=\tiny] {?} (G2);
\end{tikzpicture}
\caption{Схема обмена сообщениями $\mathrm{OM}(1)$ при $n=4$: синие стрелки~--- сообщения командующего (шаг~1), зелёные пунктирные~--- ретрансляция лояльных лейтенантов (шаг~2), красные~--- сообщения предателя $G_3$.}
\label{fig:om1_diagram}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=14cm, height=8cm,
    xlabel={Число генералов $n$},
    ylabel={Число сообщений (лог. шкала)},
    ymode=log,
    legend pos=north west,
    grid=major,
    xtick={4,7,10,13,16},
    mark size=3pt
]
\addplot[blue, mark=*, thick] coordinates {
    (4,9) (7,36) (10,81) (13,144) (16,225)
};
\addlegendentry{$m=1$}

\addplot[red, mark=square*, thick] coordinates {
    (7,156) (10,585) (13,1464)
};
\addlegendentry{$m=2$}

\addplot[green!50!black, mark=triangle*, thick] coordinates {
    (10,3609) (13,13344)
};
\addlegendentry{$m=3$}
\end{axis}
\end{tikzpicture}
\caption{Зависимость числа сообщений от $n$ для различных $m$ (логарифмическая шкала).}
\label{fig:message_complexity}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=12cm, height=7cm,
    xlabel={Конфигурация},
    ylabel={Доля корректности},
    ymin=0, ymax=1.1,
    symbolic x coords={n3m1, n4m1, n6m2, n7m2},
    xtick=data,
    xticklabels={$n{=}3{,}\;m{=}1$, $n{=}4{,}\;m{=}1$, $n{=}6{,}\;m{=}2$, $n{=}7{,}\;m{=}2$},
    grid=major,
    bar width=20pt,
    ybar,
    nodes near coords,
    every node near coord/.append style={font=\footnotesize}
]
\addplot[fill=red!40] coordinates {
    (n3m1, 0.76)
    (n4m1, 1.00)
    (n6m2, 0.84)
    (n7m2, 1.00)
};
\end{axis}
\end{tikzpicture}
\caption{Доля корректности при $n=3m$ (нарушение условия) и $n=3m+1$ (выполнение условия).}
\label{fig:boundary}
\end{figure}

% ============================================================
\section{Анализ}
% ============================================================

\subsection{Корректность алгоритма}

Результаты части~1 подтверждают, что алгоритм $\mathrm{OM}(1)$ при $n=4$ и $m=1$ корректно решает задачу для всех комбинаций командующий/предатель. Части~2 и~4 демонстрируют 100\% согласие и корректность при выполнении условия $n \geq 3m+1$ для различных масштабов и стратегий предателей.

\subsection{Граничный случай}

Часть~3 наглядно демонстрирует необходимость условия $n \geq 3m+1$. При $n = 3m$ (т.\,е. $n=3, m=1$ и $n=6, m=2$) алгоритм не гарантирует согласие: доля успешных запусков существенно ниже~1. Это согласуется с теоретическим результатом о невозможности консенсуса при $n \leq 3m$.

\subsection{Стратегии предателей}

Все четыре стратегии (RANDOM, ALWAYS\_ZERO, ALWAYS\_OPPOSITE, SPLIT) побеждаются алгоритмом при $n \geq 3m+1$ независимо от того, является ли командующий предателем. Это подтверждает устойчивость алгоритма к произвольному поведению предателей.

\subsection{Сложность сообщений}

Фактическое число сообщений в точности совпадает с теоретической формулой $T(n, m)$ для всех конфигураций. Экспоненциальный рост ($O(n^{m+1})$) хорошо виден на графике: при увеличении $m$ на единицу число сообщений возрастает на порядок.

% ============================================================
\section{Выводы}
% ============================================================

\begin{enumerate}
    \item Реализован рекурсивный алгоритм $\mathrm{OM}(m)$ для задачи византийских генералов.
    \item Экспериментально подтверждена корректность: при $n \geq 3m+1$ достигается 100\% согласие и корректность для всех протестированных конфигураций.
    \item Продемонстрирована необходимость условия $n \geq 3m+1$: при $n = 3m$ алгоритм не гарантирует консенсус.
    \item Показана устойчивость к различным стратегиям предателей: ни одна из четырёх стратегий не нарушает консенсус при выполнении условия.
    \item Фактическая сложность сообщений совпадает с теоретической $O(n^{m+1})$.
\end{enumerate}

% ============================================================
\section{Приложение}
% ============================================================

Исходный код доступен в репозитории: \url{https://github.com/AleksandrShvartz/NetworksLabs}

\begin{thebibliography}{1}
\bibitem{LSP82}
    L.~Lamport, R.~Shostak, M.~Pease.
    The Byzantine Generals Problem.
    \textit{ACM Transactions on Programming Languages and Systems}, 4(3):382--401, 1982.
\end{thebibliography}

\end{document}
